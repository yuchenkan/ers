'use strict'; /* vim: set ft=javascript: */

if (goal.match (/\bgenerated\/public\/rtld\.h$/)) return await this.invoke ('generated/public/rtld.h.g');
else if (goal.match (/[^-]\brtld$/)) return await this.invoke ('rtld.g');
else if (goal.match (/[^-]\brtld\.c\.o$/)) return await this.invoke ('rtld.c.o.g');
else if (goal.match (/\bgenerated\/recorder-binary\.h$/)) return await this.invoke ('generated/recorder-binary.h.g');
else if (goal.match (/[^-]\brecorder$/)) return await this.invoke ('recorder.g');
else if (goal.match (/-offsets\.h$/)) return await this.invoke ('goal/offset.g');
else if (goal.match (/-dedicated\.[^.]*$/)) return await this.invoke ('goal/m4.g');
else if (goal.match (/\bsyscall-dedicated\.[^.]*.m4$/))
  return await this.invoke (`${goal.match (/(.*)\bsyscall-dedicated\.[^.]*.m4$/)[1]}syscall-dedicated.m4.g`);
else if (new Set([ 'rtld-convert.c.o', 'tst/tst-rtld.S.o'  ]).has (goal)) return await this.invoke (`${goal}.g`);
else if (env.ext (goal, 'o')) return await this.invoke ('goal/compile.g');
else if (env.ext (goal, 'l')) return await this.invoke ('goal/local.g');
else if (new Set([ 'tst/tst-rtld.out' ]).has (goal)) return await this.invoke (`${goal}.g`);
else if (env.ext (goal, 'out')) return await this.invoke ('goal/tst/out.g');
else if (env.exts (goal, [ 'c', 'S', 'h', 'ld', 'm4', 'g' ])) return false;
else if (goal.match (/^tst\/tst-live-[^.]*/)) return await this.invoke ('tst/tst-live.g');
else return await this.invoke (`${goal}.g`);
